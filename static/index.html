<!DOCTYPE html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Knockout. KaPow</title>
<style>
	.container {
		margin: 1em auto 0;
		position: relative;
		width: 640px;
	}
	#video2 {
		position: absolute;
	}
	video {
		width: 640px;
		height: 480px;
	}
	.inputContainer {
		width: 175px;
		margin: 1em auto;
		display: block;
	}
</style>
<div class="container">
	<video autoplay id="video2"></video>
	<video autoplay id="video1"></video>
	<div class="inputContainer">
		<input id="interval" type="range" min=1 max=100 value=100><output for="interval"></output>
	</div>

</div>
<script type="text/javascript" src="js/jquery.js"></script>
<script src="/socket.io/socket.io.js"></script>
<script>
	"use strict";
	navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
	window.URL = window.URL || window.webkitURL;
	window.PeerConnection = window.PeerConnection || window.webkitRTCPeerConnection;

	function dbgFn(name){ return function(){ console.log(name, arguments); }; }

	var video1 = document.getElementById("video1");
	var video2 = document.getElementById("video2");
	var interval = document.getElementById("interval");

	var rtc = {
		config: {"iceServers": [{"url": "stun:stun.l.google.com:19302"}]},
		start: function(stream){
			this.stream = stream;
			this.socket = io.connect();
			this.socket.on('connect', function(){
				this.createPeerConnection();
				this.socket.emit('wantpartner');
			}.bind(this));
			this.socket.on('foundpartner', this.onfoundpartner.bind(this));
			this.socket.on('partnermessage', this.onpartnermessage.bind(this));
		},
		createPeerConnection: function(){
			// XXX this may not take a function argument anymore
			var peerConnection = new PeerConnection(this.config, dbgFn('peerconnection creation cb'));
			this.peerConnection = peerConnection;
			peerConnection.onicecandidate = this.tellpartner.bind(this, 'candidate');
			peerConnection.onaddstream = this.onaddstream.bind(this);
			peerConnection.onremovestream = dbgFn('removestream');
			peerConnection.addStream(this.stream);
		},
		// onoffersuccess: function(cb, sdp) {
		// 	console.log('offer/answer ready to go');
		// 	this.peerConnection.setLocalDescription(sdp);
		// 	cb(sdp, this.onofferanswered.bind(this));
		// },
		tellpartner: function(name, data){ this.socket.emit('tellpartner', {
			name: name, data: data
		}); },
		onpartnermessage: function(message){
			console.log('message from partner', message);
			switch (message.name) {
			case "candidate":
				if (message.data.candidate) {
					this.peerConnection.addIceCandidate(new RTCIceCandidate(message.data.candidate));
				}
				break;
			case "answer":
				this.peerConnection.setRemoteDescription(new RTCSessionDescription(message.data));
				break;
			default:
				console.warn('unknown message from candidate:', message);
			}
		},
		onofferanswered: function(partner){
			console.log('offer/answer answered');
			this.peerConnection.setRemoteDescription(new RTCSessionDescription(partner));
		},
		onaddstream: function(event) { viewer.setOtherSource(event.stream); },
		onfoundpartner: function(msg, cb) {
			console.log('Found partner!', msg);
			if (msg.initiate) {
				this.peerConnection.createOffer(
					function(sdp) {
						console.log('offer created', sdp);
						this.peerConnection.setLocalDescription(sdp);
						cb(sdp);
						// this.peerConnection.setRemoteDescription(new RTCSessionDescription(partner));
					}.bind(this), null, { has_video: true }
				);
			} else {
				this.peerConnection.setRemoteDescription(new RTCSessionDescription(msg.sdp));
				this.peerConnection.createAnswer(
					function(sdp) {
						console.log('answer created', arguments);
						this.peerConnection.setLocalDescription(sdp);
						this.tellpartner('answer', sdp);
					}.bind(this), null, { has_video: true }
				);
			}
		}
	};

	var viewer = {
		start: function(stream){
			var streamURL = URL.createObjectURL(stream);
			interval.addEventListener("input", function(){
				interval.nextSibling.value = interval.value;
				this.clearToggle();
				this.setToggle(interval.value);
			}.bind(this));
			interval.nextSibling.value = interval.value;
			video1.src = streamURL;
			this.setToggle(50);
		},
		setOtherSource: function(stream) { video2.src = URL.createObjectURL(stream); },
		setToggle: function(time){
			var toggle = true;
			this.intervalHandle = setInterval(function(){
				if (toggle) {
					video2.style.display = "none";
					toggle = false;
				} else {
					video2.style.display = "block";
					toggle = true;
				}
			}, time || 100)
		},
		clearToggle: function(){
			if (this.intervalHandle !== null) {
				clearInterval(this.intervalHandle);
				delete this.intervalHandle;
			}
		}
	}

	navigator.getUserMedia({video: true}, function(stream) {
		viewer.start(stream);
		rtc.start(stream);
	}, function(error) {
		console.log(error);
	});
</script>
